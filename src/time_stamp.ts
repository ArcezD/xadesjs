import * as XmlJs from "xmljs";
import * as XmlDSigJs from "xmldsigjs";

import { XmlXades } from "./xml";
import { XmlXadesObject } from "./xml_xades";
import { XmlXadesTaggedObject } from "./xades_tagged_object";
import { EncapsulatedPKIData } from "./encapsulated_pki_data";
import { XMLTimeStamp } from "./xml_timestamp";

export class AllDataObjectsTimeStampCollection extends XmlJs.Collection<AllDataObjectsTimeStamp> { }

export class IndividualDataObjectsTimeStampCollection extends XmlJs.Collection<IndividualDataObjectsTimeStamp> { }

export class SignatureTimeStampCollection extends XmlJs.Collection<SignatureTimeStamp> { }

export class EncapsulatedTimeStamp extends EncapsulatedPKIData {
    // Constructors
    public constructor();
    public constructor(raw: Uint8Array);
    public constructor(pki: pki.tsp.TSPResponse);
    public constructor(param1?: Uint8Array | pki.tsp.TSPResponse) {
        super(XmlXades.ElementNames.EncapsulatedTimeStamp);
        if (param1) {
            let tsp: pki.tsp.TSPResponse;
            if (param1 instanceof Uint8Array)
                tsp = new pki.tsp.TSPResponse(param1);
            else
                tsp = param1;
            this.LoadPki(tsp);
        }
    }

    /**
     * Returns the PKI representation of the encapsulated PKI data object
     * @returns PKI object
     */
    public GetPki(): pki.tsp.TSPResponse {
        return new pki.tsp.TSPResponse(this.PkiData);
    }

    /**
     * Load PkiData from an PKI object
     * @param {CRL} pki PKI object
     */
    public LoadPki(pki: pki.tsp.TSPResponse): void {
        super.LoadPki(pki);
    }
}

/**
 * <xsd:complexType name="TimeStampType">
 *   <xsd:sequence>
 *     <xsd:element name="HashDataInfo" type="HashDataInfoType" maxOccurs="unbounded"/>
 *     <xsd:choice>
 *       <xsd:element name="EncapsulatedTimeStamp" type="EncapsulatedPKIDataType"/>
 *       <xsd:element name="XMLTimeStamp" type="AnyType"/>
 *     </xsd:choice>
 *   </xsd:sequence>
 * </xsd:complexType>
 */

/**
 * This class contains timestamp information
 */
export class TimeStamp extends XmlXadesTaggedObject {
    // Private variables
    private encapsulatedTimeStamp: EncapsulatedTimeStamp | null;
    private xmlTimeStamp: XMLTimeStamp | null;

    // Public properties

    /**
     * A collection of hash data infos
     */
    public HashDataInfoCollection: HashDataInfoCollection;

    /**
     * The time-stamp generated by a TSA encoded as an ASN.1 data
     * object
     */
    public get EncapsulatedTimeStamp(): EncapsulatedTimeStamp | null {
        return this.encapsulatedTimeStamp;
    }
    public set EncapsulatedTimeStamp(value: EncapsulatedTimeStamp | null) {
        this.encapsulatedTimeStamp = value;
        if (this.encapsulatedTimeStamp) {
            this.xmlTimeStamp = null;
        }
    }

    /**
     * The time-stamp generated by a TSA encoded as a generic XML
     * timestamp
     */
    public get XMLTimeStamp(): XMLTimeStamp | null {
        return this.xmlTimeStamp;
    }
    public set XMLTimeStamp(value: XMLTimeStamp | null) {
        this.xmlTimeStamp = value;
        if (this.xmlTimeStamp) {
            this.encapsulatedTimeStamp = null;
        }
    }

    public constructor(tagName: string) {
        super(tagName);
        this.HashDataInfoCollection = new HashDataInfoCollection();
        this.encapsulatedTimeStamp = new EncapsulatedTimeStamp();
        this.xmlTimeStamp = null;
    }

    /**
     * Returns TSPResponse from current object
     */
    protected GetTspResponse(): pki.tsp.TSPResponse {
        if (this.EncapsulatedTimeStamp)
            // EncapsulatedTimeStamp
            return new pki.tsp.TSPResponse(this.EncapsulatedTimeStamp.PkiData);
        else
            // XmlTimeStamp
            throw new XmlJs.XmlError(XmlJs.XE.METHOD_NOT_IMPLEMENTED);
    }

    protected GetHash(element: Element, alg: string, transforms: XmlDSigJs.Transforms = new XmlDSigJs.Transforms()): PromiseLike<Uint8Array> {
        return new Promise((resolve, reject) => {
            let transformedString = this.GetTransformed(element, transforms);
            let buf = XmlJs.Convert.FromUtf8String(transformedString);
            XmlDSigJs.Application.crypto.subtle.digest(alg, buf)
                .then(hash => {
                    return Promise.resolve(new Uint8Array(hash));
                })
                .then(resolve, reject);
        });
    }

    protected GetTransformed(element: Element, transforms: XmlDSigJs.Transforms = new XmlDSigJs.Transforms) {
        let transformedString: string | undefined;
        // apply transforms
        if (transforms.Count)
            for (let item of transforms.GetIterator()) {
                let transform = XmlDSigJs.CryptoConfig.CreateFromName(item.Algorithm);
                transform.LoadInnerXml(element);
                transformedString = transform.GetOutput();
            }
        else {
            // default C14N transformation
            let transform = new XmlDSigJs.XmlDsigC14NTransform();
            transform.LoadInnerXml(element);
            transformedString = transform.GetOutput();
        }
        if (!transformedString)
            throw new XmlJs.XmlError(XmlJs.XE.CRYPTOGRAPHIC, "Cannot get transformed string");
        return transformedString;
    }

    // Public methods

    /**
     * Check to see if something has changed in this instance and needs to be serialized
     * @returns Flag indicating if a member needs serialization
     */
    public HasChanged(): boolean {
        let retVal = false;

        if (this.HashDataInfoCollection.Count > 0) {
            retVal = true;
        }

        if (this.encapsulatedTimeStamp && this.encapsulatedTimeStamp.HasChanged()) {
            retVal = true;
        }

        if (this.xmlTimeStamp && this.xmlTimeStamp.HasChanged()) {
            retVal = true;
        }

        return retVal;
    }

    /**
     * Load state from an XML element
     * param {Element} element XML element containing new state
     */
    public LoadXml(element: Element): void {
        super.LoadXml(element);

        this.HashDataInfoCollection.Clear();
        let xmlNodeList = element.getElementsByTagNameNS(XmlXades.NamespaceURI, XmlXades.ElementNames.HashDataInfo);
        try {
            for (let i = 0; i < xmlNodeList.length; i++) {
                let item = xmlNodeList.item(i) as Element;
                let newHashDataInfo = new HashDataInfo();
                newHashDataInfo.LoadXml(item);
                this.HashDataInfoCollection.Add(newHashDataInfo);
            }
        }
        catch (e) {
            console.warn(e);
        }
        // if (!this.HashDataInfoCollection.Count) {
        //     throw new XmlError(XE.CRYPTOGRAPHIC, "HashDataInfoCollection is empty. TimeStamp needs at least one HashDataInfo element");
        // }

        let xmlElement = this.GetElement(XmlXades.ElementNames.EncapsulatedTimeStamp, false);
        if (xmlElement) {
            this.encapsulatedTimeStamp = new EncapsulatedTimeStamp;
            this.encapsulatedTimeStamp.LoadXml(xmlElement);
            this.xmlTimeStamp = null;
        }
        else {
            xmlElement = this.GetElement(XmlXades.ElementNames.XMLTimeStamp, true);
            this.xmlTimeStamp = new XMLTimeStamp();
            this.xmlTimeStamp.LoadXml(xmlElement);
            this.encapsulatedTimeStamp = null;
        }
    }

    /**
     * Returns the XML representation of the this object
     * @returns XML element containing the state of this object
     */
    public GetXml(): Element {
        if (this.element)
            return this.element;

        let document = this.CreateDocument();
        let element = this.CreateElement(document);

        if (this.HashDataInfoCollection.Count) {
            let items = this.HashDataInfoCollection.GetIterator();
            for (let hashDataInfo of items) {
                if (hashDataInfo.HasChanged()) {
                    element.appendChild(document.importNode(hashDataInfo.GetXml(), true));
                }
            }
        }
        // else {
        //     throw new XmlError(XE.CRYPTOGRAPHIC, "HashDataInfoCollection is empty. TimeStamp needs at least one HashDataInfo element");
        // }

        if (this.encapsulatedTimeStamp && this.encapsulatedTimeStamp.HasChanged()) {
            element.appendChild(document.importNode(this.encapsulatedTimeStamp.GetXml(), true));
        }
        else {
            if (this.xmlTimeStamp && this.xmlTimeStamp.HasChanged()) {
                element.appendChild(document.importNode(this.xmlTimeStamp.GetXml(), true));
            }
            else {
                throw new XmlJs.XmlError(XmlJs.XE.CRYPTOGRAPHIC, "EncapsulatedTimeStamp or XMLTimeStamp element missing");
            }
        }

        return element;
    }

    /**
     * Creates EncapsulatedTimeStamp object for TimeStamp object using TSP service
     * @param  {Element} element 
     * @param  {string} uri URI of the Element
     * @param  {string} tspUri URI of the TSP service
     * @param  {string=SHA256} algorithm Hash algorithm. Default SHA-256
     * @param  {TransformCollection=newTransformCollection(} transforms List of transforms. Default C14N
     * @returns PromiseLike
     */
    Create(element: Element, uri: string, tspUri: string, algorithm: string = XmlDSigJs.SHA256, transforms: XmlDSigJs.Transforms = new XmlDSigJs.Transforms()): PromiseLike<TimeStamp> {
        return new Promise((resolve, reject) => {

            // Remove # from the begin of Id
            if (uri)
                uri = uri.replace(/^#/, "");

            // Get element by URI
            let el = this.GetElementById(element, uri);
            if (!el)
                throw new XmlJs.XmlError(XmlJs.XE.CRYPTOGRAPHIC, `Element with ID '${uri}' is not found b`);

            // Create TSP request
            let tspRequest = new pki.tsp.TSPRequest();
            tspRequest.DigestAlgorithm = algorithm as any;
            this.GetHash(el, algorithm, transforms)
                .then((digestValue) => {
                    // HashDataInfo
                    let hashDataInfo = new HashDataInfo();
                    hashDataInfo.Uri = uri;
                    hashDataInfo.Transforms.TransformCollection = transforms;
                    this.HashDataInfoCollection.Add(hashDataInfo);

                    tspRequest.DigestValue = digestValue;

                    return fetch(tspUri, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/timestamp-query",
                        },
                        mode: "cors",
                        body: tspRequest.Encode()
                    });
                })
                .then((response) => {
                    return response.arrayBuffer();
                })
                .then((buffer) => {
                    let uint8Buf = new Uint8Array(buffer);
                    // check TSP response
                    let tspResponse = new pki.tsp.TSPResponse(uint8Buf);
                    if (!tspResponse.TimeStampToken)
                        return reject(new XmlJs.XmlError(XmlJs.XE.CRYPTOGRAPHIC, "Can not get TSP response"));
                    // Set EncapsulatedPKIData
                    this.EncapsulatedTimeStamp!.PkiData = uint8Buf;
                    resolve(this);
                })
                .catch(reject);
        });
    }

    Verify(document?: Document): PromiseLike<boolean>;
    Verify(document?: Element): PromiseLike<boolean>;
    Verify(document?: Document | Element): PromiseLike<boolean> {
        return new Promise((resolve, reject) => {
            let _document: Document = document as Document;
            if (document && document.nodeType === XmlJs.XmlNodeType.Element)
                _document = document.ownerDocument;
            if (!document && this.element)
                _document = this.element.ownerDocument;
            if (!_document)
                throw new XmlJs.XmlError(XmlJs.XE.CRYPTOGRAPHIC, "Document is needed for verifying");

            let el: Element;
            // The SignatureTimeStamp encapsulates the time-stamp over the ds:SignatureValue element.
            if (this.name === XmlXades.ElementNames.SignatureTimeStamp) {

            }
            else {
                // find element by URI
                let id = this.HashDataInfoCollection.Item(0).Uri.replace(/^\#/, "");
                el = this.GetElementById(_document, id)!;
                if (!el)
                    throw new XmlJs.XmlError(XmlJs.XE.CRYPTOGRAPHIC, `Element by id '${id}' is not found`);
            }

            let tsp = this.GetTspResponse();
            if (!this.HashDataInfoCollection.Count)
                throw new XmlJs.XmlError(XmlJs.XE.CRYPTOGRAPHIC, `${this.name} hasn't got HashDataInfo element`);
            let content = this.GetTransformed(this.HashDataInfoCollection.Item(0).Transforms.TransformCollection);
            tsp.Verify({ data: XmlJs.Convert.FromUtf8String(content).buffer }).then(resolve, reject);
        });
    }
}

export class AllDataObjectsTimeStamp extends TimeStamp {
    constructor() {
        super(XmlXades.ElementNames.AllDataObjectsTimeStamp);
    }
}

export class IndividualDataObjectsTimeStamp extends TimeStamp {
    constructor() {
        super(XmlXades.ElementNames.IndividualDataObjectsTimeStamp);
    }
}

export class SignatureTimeStamp extends TimeStamp {
    constructor() {
        super(XmlXades.ElementNames.SignatureTimeStamp);
    }
}
