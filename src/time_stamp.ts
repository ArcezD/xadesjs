namespace xadesjs.pro {

    export class AllDataObjectsTimeStampCollection extends Collection<AllDataObjectsTimeStamp> { }

    export class IndividualDataObjectsTimeStampCollection extends Collection<IndividualDataObjectsTimeStamp> { }

    export class SignatureTimeStampCollection extends Collection<SignatureTimeStamp> { }

    export class EncapsulatedTimeStamp extends EncapsulatedPKIData {
        // Constructors
        public constructor();
        public constructor(raw: Uint8Array);
        public constructor(pki: pki.tsp.TSPResponse);
        public constructor(param1?: Uint8Array | pki.tsp.TSPResponse) {
            super(XmlXades.ElementNames.EncapsulatedTimeStamp);
            if (param1) {
                let tsp: pki.tsp.TSPResponse;
                if (param1 instanceof Uint8Array)
                    tsp = new pki.tsp.TSPResponse(param1);
                else
                    tsp = param1;
                this.LoadPki(tsp);
            }
        }

        /**
		 * Returns the PKI representation of the encapsulated PKI data object
         * @returns PKI object
		 */
        public GetPki(): pki.tsp.TSPResponse {
            return new pki.tsp.TSPResponse(this.PkiData);
        }

        /**
		 * Load PkiData from an PKI object
         * @param {CRL} pki PKI object
		 */
        public LoadPki(pki: pki.tsp.TSPResponse): void {
            super.LoadPki(pki);
        }
    }

    /**
     * <xsd:complexType name="TimeStampType">
     *   <xsd:sequence>
     *     <xsd:element name="HashDataInfo" type="HashDataInfoType" maxOccurs="unbounded"/>
     *     <xsd:choice>
     *       <xsd:element name="EncapsulatedTimeStamp" type="EncapsulatedPKIDataType"/>
     *       <xsd:element name="XMLTimeStamp" type="AnyType"/>
     *     </xsd:choice>
     *   </xsd:sequence>
     * </xsd:complexType>
     */

    /**
     * This class contains timestamp information
     */
    export class TimeStamp extends XmlXadesTaggedObject {
        // Private variables
        private encapsulatedTimeStamp: EncapsulatedTimeStamp;
        private xmlTimeStamp: XMLTimeStamp;

        // Public properties

		/**
		 * A collection of hash data infos
		 */
        public HashDataInfoCollection: HashDataInfoCollection;

		/**
		 * The time-stamp generated by a TSA encoded as an ASN.1 data
		 * object
		 */
        public get EncapsulatedTimeStamp(): EncapsulatedTimeStamp {
            return this.encapsulatedTimeStamp;
        }
        public set EncapsulatedTimeStamp(value: EncapsulatedTimeStamp) {
            this.encapsulatedTimeStamp = value;
            if (this.encapsulatedTimeStamp != null) {
                this.xmlTimeStamp = null;
            }
        }

		/**
		 * The time-stamp generated by a TSA encoded as a generic XML
		 * timestamp
		 */
        public get XMLTimeStamp(): XMLTimeStamp {
            return this.xmlTimeStamp;
        }
        public set XMLTimeStamp(value: XMLTimeStamp) {
            this.xmlTimeStamp = value;
            if (this.xmlTimeStamp != null) {
                this.encapsulatedTimeStamp = null;
            }
        }

        public constructor(tagName: string) {
            super(tagName);
            this.HashDataInfoCollection = new HashDataInfoCollection();
            this.encapsulatedTimeStamp = new EncapsulatedTimeStamp();
            this.xmlTimeStamp = null;
        }

        // Protected methods

        protected GetXmlObjectName() {
            return this.TagName;
        }

        /**
         * Returns TSPResponse from current object
         */
        protected GetTspResponse(): pki.tsp.TSPResponse {
            if (this.EncapsulatedTimeStamp)
                // EncapsulatedTimeStamp
                return new pki.tsp.TSPResponse(this.EncapsulatedTimeStamp.PkiData);
            else
                // XmlTimeStamp
                throw new XmlError(XE.METHOD_NOT_IMPLEMENTED);
        }

        protected GetHash(element: Element, alg: string, transforms: TransformCollection = new TransformCollection()): PromiseLike<Uint8Array> {
            return new Promise((resolve, reject) => {
                let transformedString = this.GetTransformed(element, transforms);
                let buf = Convert.ToBufferUtf8String(transformedString);
                Application.crypto.subtle.digest(alg, buf)
                    .then((hash: ArrayBuffer) => {
                        return Promise.resolve(new Uint8Array(hash));
                    })
                    .then(resolve, reject);
            });
        }

        protected GetTransformed(element: Element, transforms: TransformCollection = new TransformCollection()): string {
            let transformedString: string;
            // apply transforms
            if (transforms.Count)
                for (let item of transforms.GetIterator()) {
                    let transform = CryptoConfig.CreateFromName(item.Algorithm);
                    transform.LoadInnerXml(element);
                    transformedString = transform.GetOutput();
                }
            else {
                // default C14N transformation
                let transform = new XmlDsigC14NTransform();
                transform.LoadInnerXml(element);
                transformedString = transform.GetOutput();
            }
            return transformedString;
        }

        // Public methods

		/**
		 * Check to see if something has changed in this instance and needs to be serialized
         * @returns Flag indicating if a member needs serialization
		 */
        public HasChanged(): boolean {
            let retVal = false;

            if (this.HashDataInfoCollection.Count > 0) {
                retVal = true;
            }

            if (this.encapsulatedTimeStamp != null && this.encapsulatedTimeStamp.HasChanged()) {
                retVal = true;
            }

            if (this.xmlTimeStamp != null && this.xmlTimeStamp.HasChanged()) {
                retVal = true;
            }

            return retVal;
        }

		/**
		 * Load state from an XML element
         * param {Element} element XML element containing new state
		 */
        public LoadXml(element: Element): void {
            super.LoadXml(element);

            this.HashDataInfoCollection.Clear();
            let xmlNodeList = element.getElementsByTagNameNS(XmlXades.NamespaceURI, XmlXades.ElementNames.HashDataInfo);
            try {
                for (let i = 0; i < xmlNodeList.length; i++) {
                    let item = xmlNodeList.item(i) as Element;
                    let newHashDataInfo = new HashDataInfo();
                    newHashDataInfo.LoadXml(item);
                    this.HashDataInfoCollection.Add(newHashDataInfo);
                }
            }
            catch (e) {
                console.warn(e);
            }
            // if (!this.HashDataInfoCollection.Count) {
            //     throw new XmlError(XE.CRYPTOGRAPHIC, "HashDataInfoCollection is empty. TimeStamp needs at least one HashDataInfo element");
            // }

            let xmlElement = this.GetElement(element, XmlXades.ElementNames.EncapsulatedTimeStamp, false);
            if (xmlElement) {
                this.encapsulatedTimeStamp = new EncapsulatedTimeStamp;
                this.encapsulatedTimeStamp.LoadXml(xmlElement);
                this.xmlTimeStamp = null;
            }
            else {
                xmlElement = this.GetElement(element, XmlXades.ElementNames.XMLTimeStamp, false);
                if (xmlElement) {
                    this.xmlTimeStamp = new XMLTimeStamp();
                    this.xmlTimeStamp.LoadXml(xmlElement);
                    this.encapsulatedTimeStamp = null;
                }
                else {
                    throw new XmlError(XE.CRYPTOGRAPHIC, "EncapsulatedTimeStamp or XMLTimeStamp missing");
                }
            }
        }

		/**
		 * Returns the XML representation of the this object
         * @returns XML element containing the state of this object
		 */
        public GetXml(): Element {
            if (this.element)
                return this.element;

            let document = this.CreateDocument();
            let element = this.CreateElement(document);

            if (this.HashDataInfoCollection.Count) {
                let items = this.HashDataInfoCollection.GetIterator();
                for (let hashDataInfo of items) {
                    if (hashDataInfo.HasChanged()) {
                        element.appendChild(document.importNode(hashDataInfo.GetXml(), true));
                    }
                }
            }
            // else {
            //     throw new XmlError(XE.CRYPTOGRAPHIC, "HashDataInfoCollection is empty. TimeStamp needs at least one HashDataInfo element");
            // }

            if (this.encapsulatedTimeStamp != null && this.encapsulatedTimeStamp.HasChanged()) {
                element.appendChild(document.importNode(this.encapsulatedTimeStamp.GetXml(), true));
            }
            else {
                if (this.xmlTimeStamp != null && this.xmlTimeStamp.HasChanged()) {
                    element.appendChild(document.importNode(this.xmlTimeStamp.GetXml(), true));
                }
                else {
                    throw new XmlError(XE.CRYPTOGRAPHIC, "EncapsulatedTimeStamp or XMLTimeStamp element missing");
                }
            }

            return element;
        }

        /**
         * Creates EncapsulatedTimeStamp object for TimeStamp object using TSP service
         * @param  {Element} element 
         * @param  {string} uri URI of the Element
         * @param  {string} tspUri URI of the TSP service
         * @param  {string=SHA256} algorithm Hash algorithm. Default SHA-256
         * @param  {TransformCollection=newTransformCollection(} transforms List of transforms. Default C14N
         * @returns PromiseLike
         */
        Create(element: Element, uri: string, tspUri: string, algorithm: string = SHA256, transforms: TransformCollection = new TransformCollection()): PromiseLike<TimeStamp> {
            return new Promise((resolve, reject) => {

                // Remove # from the begin of Id
                if (uri)
                    uri = uri.replace(/^#/, "");

                // Get element by URI
                let el = this.GetElementById(element, uri);
                if (!el)
                    throw new XmlError(XE.CRYPTOGRAPHIC, `Element with ID '${uri}' is not found b`);

                // Create TSP request
                let tspRequest = new pki.tsp.TSPRequest();
                tspRequest.DigestAlgorithm = algorithm as any;
                this.GetHash(el, algorithm, transforms)
                    .then((digestValue) => {
                        // HashDataInfo
                        let hashDataInfo = new HashDataInfo();
                        hashDataInfo.Uri = uri;
                        hashDataInfo.Transforms.TransformCollection = transforms;
                        this.HashDataInfoCollection.Add(hashDataInfo);

                        tspRequest.DigestValue = digestValue;

                        return fetch(tspUri, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/timestamp-query",
                            },
                            mode: "cors",
                            body: tspRequest.Encode()
                        });
                    })
                    .then((response) => {
                        return response.arrayBuffer();
                    })
                    .then((buffer) => {
                        let uint8Buf = new Uint8Array(buffer);
                        // check TSP response
                        let tspResponse = new pki.tsp.TSPResponse(uint8Buf);
                        if (!tspResponse.TimeStampToken)
                            return reject(new XmlError(XE.CRYPTOGRAPHIC, "Can not get TSP response"));
                        // Set EncapsulatedPKIData
                        this.EncapsulatedTimeStamp.PkiData = uint8Buf;
                        resolve(this);
                    })
                    .catch(reject);
            });
        }

        Verify(document?: Document): PromiseLike<boolean>;
        Verify(document?: Element): PromiseLike<boolean>;
        Verify(document: Document | Element = null): PromiseLike<boolean> {
            return new Promise((resolve, reject) => {
                let _document: Document = document as Document;
                if (document && document.nodeType === XmlNodeType.Element)
                    _document = document.ownerDocument;
                if (!document && this.element)
                    _document = this.element.ownerDocument;
                if (!_document)
                    throw new XmlError(XE.CRYPTOGRAPHIC, "Document is needed for verifying");

                let el: Element;
                // The SignatureTimeStamp encapsulates the time-stamp over the ds:SignatureValue element.
                if (this.TagName === XmlXades.ElementNames.SignatureTimeStamp) {

                }
                else {
                    // find element by URI
                    let id = this.HashDataInfoCollection.Item(0).Uri.replace(/^\#/, "");
                    el = this.GetElementById(_document, id);
                    if (!el)
                        throw new XmlError(XE.CRYPTOGRAPHIC, `Element by id '${id}' is not found`);
                }

                let tsp = this.GetTspResponse();
                if (!this.HashDataInfoCollection.Count)
                    throw new XmlError(XE.CRYPTOGRAPHIC, `${this.TagName} hasn't got HashDataInfo element`);
                let content = this.GetTransformed(el, this.HashDataInfoCollection.Item(0).Transforms.TransformCollection);
                tsp.Verify({ data: Convert.ToBufferUtf8String(content).buffer }).then(resolve, reject);
            });
        }
    }

    export class AllDataObjectsTimeStamp extends TimeStamp {
        constructor() {
            super(XmlXades.ElementNames.AllDataObjectsTimeStamp);
        }
    }

    export class IndividualDataObjectsTimeStamp extends TimeStamp {
        constructor() {
            super(XmlXades.ElementNames.IndividualDataObjectsTimeStamp);
        }
    }

    export class SignatureTimeStamp extends TimeStamp {
        constructor() {
            super(XmlXades.ElementNames.SignatureTimeStamp);
        }
    }
}